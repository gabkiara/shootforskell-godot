DEVLOGS

 

25/11/24
Shit to add.

> Shop
- Remote control shaped pop up panel/menu
- Volume buttons as speed buffs
- Potentially add trails, maybe add particles on it
- Add more DVD sprite 

> Click interaction? Collision with mouse click to control DVD collision
> DVD Main Menu Intro
> More music
> 



Based on your current `target.gd` script, you're already handling the movement, collision detection, counter increments, and particle effects for the bouncing DVD logo (target). The mouse click effects will need to be integrated in a way that makes sense alongside your existing logic.

Here's the overall approach:
- **Input Handling**: You need to detect mouse clicks in the parent node (your world scene, which is likely `Node2D`), but for simplicity, we'll ensure that the effect is applied to your `target.gd` when the world node detects a mouse click.
- **Target's Reaction**: Once the click is detected, you can modify the `custom_velocity` (or create a force) to simulate an effect, like changing the target's velocity or direction.

You don’t need to move the mouse input logic directly into `target.gd`, as it's better to handle it in the parent node (`world.gd`) and then call a function on the target. Below are the modifications you should make to both `target.gd` and `world.gd`.

### 1. **Modifications to `target.gd`** (DVD logo behavior)
You’ll add a method in `target.gd` to handle the mouse click effect. This will modify the `custom_velocity` or trigger some reaction when clicked.

```gd
extends CharacterBody2D

@onready var sprite = $Sprite2D
@onready var counter_label = $"../Label"  # Reference to the Label node
@onready var particles = $CPUParticles2D  # Reference to the Particles2D node
@onready var sfx_col: AudioStreamPlayer = $sfx_col

var speed: float = 300
var custom_velocity: Vector2 = Vector2.ZERO  # Rename to avoid conflict with the built-in 'velocity'
var corner_hit_chance: float = 0.25  # 25% chance to introduce randomness on collision

func _ready() -> void:
	particles.emitting = false
	custom_velocity = _random_up_direction() * speed
	update_counter_label()

func _random_up_direction() -> Vector2:
	var angle = deg_to_rad(randf_range(0, 180))
	return Vector2(cos(angle), sin(angle)).normalized()

func _physics_process(delta: float) -> void:
	var col = move_and_collide(custom_velocity * delta)
	
	if col:
		trigger_particles(col.get_position(), col.get_normal())
		counter.increment_counter(1)  # Increment counter by 1 for wall hit
		sfx_col.play()
		
		if is_corner_hit(col.get_normal()):
			counter.increment_counter(10)  # Increment by 10 for corner hit
		custom_velocity = custom_velocity.bounce(col.get_normal())
		update_counter_label()

func is_corner_hit(collision_normal: Vector2) -> bool:
	var threshold = 100
	var angle1 = Vector2(1, 0)
	var angle2 = Vector2(0, 1)
	var dot1 = collision_normal.dot(angle1)
	var dot2 = collision_normal.dot(angle2)
	return abs(dot1) > threshold or abs(dot2) > threshold

func update_counter_label() -> void:
	counter_label.text = str(counter.get_counter())  # Get counter from Counter singleton

func trigger_particles(collision_point: Vector2, collision_normal: Vector2) -> void:
	var sprite_width: float = 161
	var sprite_height: float = 75
	var offset_distance = 10  # Small offset for a cleaner effect
	
	# Apply the offset based on the collision normal
	var offset = collision_normal.normalized() * offset_distance
	var particle_position = collision_point + offset  # New position for particle emission

	var emit_area_size = Vector2.ZERO
	if collision_normal.x != 0:
		emit_area_size = Vector2(0, sprite_height)
		particles.global_position = Vector2(particle_position.x, sprite.global_position.y - sprite_height / 2)
	elif collision_normal.y != 0:
		emit_area_size = Vector2(sprite_width, 0)
		particles.global_position = Vector2(sprite.global_position.x - sprite_width / 2, particle_position.y)

	particles.scale = emit_area_size
	particles.emitting = true  # Start emitting particles

	# Emit particles for a short duration
	await get_tree().create_timer(0.1).timeout
	particles.emitting = false  # Stop emitting particles

# New method to apply effects on mouse click
func apply_click_effect(click_position: Vector2) -> void:
	# Calculate the direction to the click and apply a force or new velocity to the target
	var direction_to_click = (click_position - position).normalized()
	
	# Optionally, you could apply a "bounce" or adjust the velocity by a factor
	custom_velocity = custom_velocity.bounce(direction_to_click) * 1.5  # Bounce and speed up slightly
	update_counter_label()  # Make sure the counter updates if needed (in case you want to track click effects)
```

### 2. **Modifications to `world.gd`** (World node handling the input)
Now, you need to handle the mouse input in the world node and pass it to the `target` (DVD logo) using the new method `apply_click_effect`.

```gd
extends Node2D

@onready var target: Node2D  # Reference to the target (DVD logo)

func _ready():
    set_process_input(true)  # Enable input processing for this node

func _input(event):
    # Check if the left mouse button was pressed
    if event is InputEventMouseButton and event.button_index == BUTTON_LEFT and event.pressed:
        # Get the mouse click position (in world coordinates)
        var click_position = event.position
        
        # Pass the click effect to the target (DVD logo)
        if target:
            target.apply_click_effect(click_position)
```

### How It Works:

1. **In the `world.gd`**:
   - The `_input(event)` method listens for mouse clicks and passes the `click_position` to the `target`.
   - When the player clicks the mouse, the world node sends the click position to the `target.gd`.

2. **In the `target.gd`**:
   - The `apply_click_effect(click_position)` method is invoked when the world node detects a click.
   - The method calculates the direction from the click position to the target’s current position and then alters the `custom_velocity` to simulate an effect (like bouncing in the direction of the click or applying a force).

### Key Adjustments:
- The mouse input is **not directly handled in the `target.gd`**, but is instead processed by the **world node** (`world.gd`), which passes the click information to the target.
- The `apply_click_effect(click_position)` method in `target.gd` modifies the velocity based on the click, allowing you to control the behavior of the target upon click.
  
### Additional Thoughts:
- **Effects on click**: You could tweak the click behavior (e.g., by applying a stronger force or creating a more significant change in the target’s movement).
- **Particles and Sound**: You might also want to trigger particle effects or sound effects when a click happens. This could be added to the `apply_click_effect` method in `target.gd`.
  
This should give you the desired functionality for handling mouse clicks and applying effects to the target, while keeping the input logic clean and manageable in the world scene.